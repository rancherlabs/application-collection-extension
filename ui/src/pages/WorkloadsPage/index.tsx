import { Stack, Typography } from '@mui/material'
import { findAllHelmCharts } from '../../clients/helm'
import { useEffect, useState } from 'react'
import { createDockerDesktopClient } from '@docker/extension-api-client'
import WorkloadCard, { LoadingWorkloadCard, Workload } from './components/WorkloadCard'
import { checkKubernetes, getServices } from '../../clients/kubectl'
import { V1ServicePort, V1ServiceSpec } from '@kubernetes/client-node'
import { useAuth } from '../../AuthContext'
import { componentsClient } from '../../clients/backend'
import { ArtifactListItemReducedDTO, ArtifactListItemReducedDTOPackagingFormatEnum, BranchDTO, ComponentDTO } from '../../../autogenerated/client/backend'
import { compareVersions } from '../../clients/util'
import { enqueueSnackbar } from 'notistack'
import { checkDocker } from '../../clients/docker'

const ddClient = createDockerDesktopClient()

export default function WorkloadsPage() {
  const [ state, setState ] = useState<'loading' | 'ready' | 'error'>('loading')
  const [ workloads, setWorkloads ] = useState<Workload[]>([])
  const [ updates, setUpdates ] = useState<{ workload: string, updateVersion?: ArtifactListItemReducedDTO, updateBranchVersion?: ArtifactListItemReducedDTO }[]>()
  const auth = useAuth()

  useEffect(() => {
    async function fetchData() {
      try {
        const charts = await findAllHelmCharts(ddClient)
        const workloads = await Promise.all<Promise<Workload>[]>(charts.map(async (chart) => {

          const chartPortMappings: {
            targetPort: number,
            nodePort: number,
            protocol: string
          }[] = []

          try {
            const chartServices = await getServices(ddClient, [{ key: 'app.kubernetes.io/instance', value: chart.name }])

            chartServices
              .filter(s => s.spec && s.spec.type === 'NodePort' && s.spec.ports)
              .forEach(nodePort => ((nodePort.spec as V1ServiceSpec).ports as V1ServicePort[])
                .forEach(port => {
                  chartPortMappings.push({
                    targetPort: port.targetPort as number,
                    nodePort: port.nodePort as number,
                    protocol: port.protocol as string
                  })
                })
              )
          } catch (e) {
            console.error(`Unexpected error getting helm chart services [name=${chart.name}]`, e)
          }
          return { 
            ...chart, 
            portMappings: chartPortMappings
          }
        }))

        setWorkloads(workloads)
        setState('ready')
      } catch (e) {
        console.error('Unexpected error listing helm releases', e)
        enqueueSnackbar('Unexpected error listing helm releases')
        setState('error')
      }
    }
  
    checkDocker(ddClient)
      .then(() => checkKubernetes(ddClient)
        .then(() => fetchData())
        .catch(e => {
          console.error(e)
          enqueueSnackbar('Error with kubernetes, make sure the cluster is up and reachable')
          setState('error')
        }))
      .catch(e => {
        console.error(e)
        enqueueSnackbar('Error with docker engine, make sure it is running')
        setState('error')
      })
  }, [])

  useEffect(() => {
    function appSlugName(name: string): string {
      const chunks = name.split('-')
      return chunks.filter((chunk, i) => i < chunks.length - 1).join('-')
    }

    async function checkForUpdates() {
      const components = await Promise.all(workloads
        .map(workload => appSlugName(workload.name))
        .reduce((acc, curr) => acc.includes(curr) ? acc : [...acc, curr], new Array<string>())
        .flatMap(async (appName) => {
          const response = await componentsClient(auth?.auth || null).getComponent(appName)
          return response.data
        }))

      const workloadsWithUpdates = workloads.map(workload => {
        const component = components.find(component => component.slug_name === appSlugName(workload.name)) as ComponentDTO

        const currentBranch = component.branches.find(branch => workload.app_version.match(new RegExp(branch.branch_pattern))) as BranchDTO
        const updateVersion = currentBranch.versions?.find(version => compareVersions(version.version_number, workload.app_version) > 0 &&
          version.artifacts.find(artifact => artifact.packaging_format === ArtifactListItemReducedDTOPackagingFormatEnum.HelmChart))
          ?.artifacts.find(artifact => artifact.packaging_format === ArtifactListItemReducedDTOPackagingFormatEnum.HelmChart)
        
        const higherBranch = component.branches.find(branch => branch !== currentBranch && 
          branch.versions && 
          branch.versions.length > 0 && 
          branch.versions.find(version => compareVersions(version.version_number, workload.app_version) > 0))
        const updateBranchVersion = higherBranch?.versions?.flatMap(version => version.artifacts)
          .find(artifact => artifact.packaging_format === ArtifactListItemReducedDTOPackagingFormatEnum.HelmChart)
        
        return {
          workload: workload.name,
          updateBranchVersion: updateBranchVersion,
          updateVersion: updateVersion
        }
      })

      setUpdates(workloadsWithUpdates)
    }

    if (workloads.length > 0) checkForUpdates()
  }, [workloads])

  return (
    <>
      <Typography variant='h2'>Workloads</Typography>
      <Typography variant='h5'>Manage the applications installed through the extension</Typography>
      <Stack direction='column' spacing={ 2 } sx={ { mt: 2 } }>
        {
          state === 'loading' ?
            <>
              <LoadingWorkloadCard />
              <LoadingWorkloadCard />
              <LoadingWorkloadCard />
            </> :
            workloads.length > 0 ? 
              workloads.map(workload => <WorkloadCard 
                key={ workload.name } 
                workload={ workload } 
                updateVersion={ updates ? updates.find(u => u.workload === workload.name)?.updateVersion || null : undefined }
                updateBranchVersion={ updates ? updates.find(u => u.workload === workload.name)?.updateBranchVersion || null : undefined } />) :
              <Typography variant='body2'>
                { state === 'error' ? 'Error listing workloads.' : <>There is no application running yet.</> }
              </Typography>
        }
      </Stack>
    </>
  )
}
