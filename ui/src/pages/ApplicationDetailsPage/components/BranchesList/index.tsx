import { Stack, Typography } from '@mui/material'
import { ApplicationDTOPackagingFormatEnum, BranchDTO, VersionDTO } from '../../../../../autogenerated/client/backend'
import { useEffect } from 'react'
import { checkKubernetes } from '../../../../clients/kubectl'
import { createDockerDesktopClient } from '@docker/extension-api-client'
import { enqueueSnackbar } from 'notistack'
import { checkDocker } from '../../../../clients/docker'
import { sortArtifacts } from '../../../../clients/util'
import BranchCard from './BranchCard'

const ddClient = createDockerDesktopClient()

export default function BranchesList({ branches, packagingFormat }: { branches: BranchDTO[], packagingFormat?: ApplicationDTOPackagingFormatEnum }) {
  if (!packagingFormat) {
    return <Typography>This application cannot be deployed yet</Typography>
  }
  
  useEffect(() => {
    switch(packagingFormat) {
      case 'HELM_CHART':
        checkKubernetes(ddClient)
          .catch(e => {
            console.error(e)
            enqueueSnackbar('Error with kubernetes, make sure the cluster is up and reachable')
          })
        break
      case 'CONTAINER':
        checkDocker(ddClient)
          .catch(e => {
            console.error(e)
            enqueueSnackbar('Error with docker engine, make sure it is running')
          })
        break
    }
  }, [])
  
  return (
    <Stack spacing={ 2 }>
      {
        branches
          .filter(branch => branch.versions && branch.versions.length > 0 && branch.versions.find(v => v.artifacts.find(a => a.packaging_format === packagingFormat)))
          .flatMap(branch => {
            const version = (branch.versions as VersionDTO[]).find(v => v.artifacts.sort(sortArtifacts).find(a => a.packaging_format === packagingFormat)) as VersionDTO
            return {
              branch: { name: branch.branch_name, pattern: branch.branch_pattern },
              version: version.version_number,
              artifact: version.artifacts.reverse().find(a => a.packaging_format === packagingFormat)
            }
          })
          .filter(({ artifact }) => artifact !== undefined)
          .map(({ branch, version, artifact }) => artifact && 
          <BranchCard 
            key={ artifact?.name } 
            branch={ branch } 
            version={ version } 
            artifact={ artifact } />
          )
      }
    </Stack>
  )
}